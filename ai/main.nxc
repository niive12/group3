//sort = 35-45
//hvid = 55-65

#define THRESHOLD 50

#define MOT_R       OUT_B  //B
#define MOT_L       OUT_A  //A
#define MOTOR       OUT_AB //C
#define LEFT        IN_1
#define CENTER     	IN_2
#define RIGHT       IN_3

void follow_line_f(char basespeed=80);
void turn_right(bool forward=true);
void turn_left();
void back();
void execute();

task main(){
  SetSensorLight(LEFT);
  SetSensorLight(RIGHT);
  SetSensorLight(CENTER);
  
  /*follow_line_f(); Wait(1000);
  back();
  back();*/
  execute();
}

void execute(){
 char moves[300];
  moves[0]='r';
  moves[1]='r';
  moves[2]='u';
  moves[3]='l';
  moves[4]='d';
  moves[5]='s';
  moves[6]='s';
  bool running = true;
  char current = moves[1];
  char previous = moves[0];
  int index = 1;
  while(running){
	TextOut(40,24, NumToStr(current)+ " " +NumToStr(index));
	Wait(2000);
	switch(current){
	  case 'l':
		switch(previous){
		  case 'l':
			follow_line_f();
			break;
		  case 'u':
			turn_left();
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			turn_left();
			follow_line_f();
			break;
		  case 'L':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  case 'U':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'R':
			back();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'u':
		switch(previous){
		  case 'l':
			turn_right();
			follow_line_f();
			break;
		  case 'u':
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			turn_right();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'U':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  case 'D':
			back();
			follow_line_f();
			break;
		  case 'R':
			back();
			turn_right();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'd':
	    switch(previous){
		  case 'l':
			turn_left();
			follow_line_f();
			break;
		  case 'u':
			turn_left();
			turn_left();
			follow_line_f();
			break;
		  case 'd':
			follow_line_f();
			break;
		  case 'r':
			turn_right();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'U':
			back();
			follow_line_f();
			break;
		  case 'D':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  case 'R':
			back();
			turn_left();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'r':
		switch(previous){
		  case 'l':
			turn_right();
			turn_right();
			follow_line_f();
			break;
		  case 'u':
			turn_right();
			follow_line_f();
			break;
		  case 'd':
			turn_left();
			follow_line_f();
			break;
		  case 'r':
			follow_line_f();
			break;
		  case 'L':
			back();
			follow_line_f();
			break;
		  case 'U':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'R':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  default:
			break;
		}
		break;
	  case 'L':
		switch(previous){
		  case 'l':
		    follow_line_f();
			break;
		  case 'u':
			turn_left();
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			turn_left();
			follow_line_f();
			break;
		  case 'L':
			follow_line_f();
			break;
		  case 'U':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'R':
			back();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'U':
		switch(previous){
		  case 'l':
            turn_right();
			follow_line_f();
			break;
		  case 'u':
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			turn_right();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'U':
			follow_line_f();
			break;
		  case 'D':
			back();
			follow_line_f();
			break;
		  case 'R':
			back();
			turn_right();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'D':
		switch(previous){
		  case 'l':
            turn_left();
			follow_line_f();
			break;
		  case 'u':
			turn_right();
			turn_right();
			follow_line_f();
			break;
		  case 'd':
			follow_line_f();
			break;
		  case 'r':
			turn_right();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'U':
			back();
			follow_line_f();
			break;
		  case 'D':
			follow_line_f();
			break;
		  case 'R':
			back();
			turn_left();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'R':
		switch(previous){
		  case 'l':
            turn_right();
            turn_right();
			follow_line_f();
			break;
		  case 'u':
			turn_right();
			follow_line_f();
			break;
		  case 'd':
			turn_left();
			follow_line_f();
			break;
		  case 'r':
			follow_line_f();
			break;
		  case 'L':
			back();
			follow_line_f();
			break;
		  case 'U':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'R':
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 's':
		TextOut(40,24,  "FINISH");
		running = false;
		Wait(1000);
		break;
	}
  
    index++;
	previous = current;
	current = moves[index];
	
  }
  
  
}

void follow_line_f(char basespeed = 80){
  const char EXPECTED_SENSOR_ERROR = 1; //mismatch i lys fra rummet.
  char left_error;
  char left_speed;
  char right_speed;
  char left_previous_error = 0;
  float P, I = 0;
  int   D;
  float kP = 1;
  float kI = 0.02;
  float kD = 0.01;
  if(basespeed < 0){
	kP = 1.5;
	kI = 0;
	kD = 0.01;
  }
  OnFwd(MOT_L, 60);
  OnFwd(MOT_R, 60);
  Wait(400);
  int correction = 0;
  bool line_has_ended = false;
  while(!line_has_ended){
	TextOut(1,8,  "left");
	TextOut(75,8,  "right");
	TextOut(1,1,  NumToStr(Sensor(LEFT)));
	TextOut(85,1, NumToStr(Sensor(RIGHT)));
	
	if( (Sensor(LEFT)  < THRESHOLD) &&
	  (Sensor(RIGHT) < THRESHOLD)
	){
	  Off(MOTOR);
	  TextOut(40,24,  "KRYDS");
	  line_has_ended = true;
	} else {
	  TextOut(40,24,  "     ");
	  TextOut(1,16, NumToStr(left_speed));
	  TextOut(80,16, NumToStr(right_speed));
	  left_error = Sensor(LEFT) - Sensor(RIGHT);
	  TextOut(30,1,"        ");
	  TextOut(40,1,NumToStr(left_error));
	  // lighting mismatch correction
	  if(left_error > EXPECTED_SENSOR_ERROR){
		left_error -= EXPECTED_SENSOR_ERROR;
	  } else if(left_error < -EXPECTED_SENSOR_ERROR){
		left_error += EXPECTED_SENSOR_ERROR;
	  } else {
		left_error = 0;
	  }
	  P = left_error;
	  I = I + left_error;
	  D = left_error - left_previous_error;
	  left_previous_error = left_error;
	  correction = P * kP + I * kI + D * kD;
	  //roundoff to avoid mayhem
	  if(correction > 25 ){
		correction = 25;
	  } else if(correction < -25){
		correction = -25;
	  }
	  left_speed =  basespeed + correction;
	  right_speed = basespeed - correction;
	  
	  OnFwd(MOT_L, left_speed);
	  OnFwd(MOT_R, right_speed);
	}
	Wait(10); // Generate 100 hz controller
  }
}

void back(){
  OnFwd(MOT_L, -30);
  OnFwd(MOT_R, -30);
  Wait(700);
  turn_right(false);
  Wait(1000);
  follow_line_f(80);
}

void turn_left(){
  OnFwd(MOT_L, 30);
  OnFwd(MOT_R, 30);
  Wait(600);
  OnFwd(MOT_L, -60);
  OnFwd(MOT_R, 60);
  Wait(500);
  bool turn_completed = false;
  while(!turn_completed){
	if(Sensor(CENTER) < 65)
	  turn_completed = true;
  }
  Off(MOTOR);
} 

void turn_right(bool forward = true){
  if(forward){
	OnFwd(MOT_L, 30);
	OnFwd(MOT_R, 30);
	Wait(650);
  }
  OnFwd(MOT_L, 50);
  OnFwd(MOT_R, -50);
  Wait(700);
  bool turn_completed = false;
  while(!turn_completed){
	if(Sensor(CENTER) < 65)
	  turn_completed = true;
  }
  Off(MOTOR);
}