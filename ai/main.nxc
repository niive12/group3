//sort = 35-45
//hvid = 55-65
#include "result_2014.h"

#define THRESHOLD 60
#define THRESHOLD_CENTER 50

#define MOT_R       OUT_B  //B
#define MOT_L       OUT_A  //A
#define MOTOR       OUT_AB //C
#define LEFT        IN_1
#define CENTER     	IN_2
#define RIGHT       IN_3

void follow_line_f(char basespeed=90);
void turn_right(bool forward=true);
void turn_left(bool forward=true);
void back();
void execute();

task main(){
  SetSensorLight(LEFT);
  SetSensorLight(RIGHT);
  SetSensorLight(CENTER);
  follow_line_f();
  
  for(int i = 0;i<20;i++){
  back();
  follow_line_f();
  }
}

void execute(){
 char moves[300];
  moves[0]='u';
  moves[1]='u';
  moves[2]='L';
  moves[3]='r';
  moves[4]='d';
  moves[5]='d';
  moves[6]='\0';
  bool running = true;
//   char current = moves[0];
  char current = path[0];
  char previous = current;
  int index = 0;
  while(running){
// 	TextOut(40,24, NumToStr(current)+ " " +NumToStr(index));
// 	Wait(2000);
	switch(current){
	  case 'l':
		switch(previous){
		  case 'l':
			follow_line_f();
			break;
		  case 'u':
			turn_left();
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			turn_left();
			follow_line_f();
			break;
		  case 'L':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  case 'U':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'R':
			back();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'u':
		switch(previous){
		  case 'l':
			turn_right();
			follow_line_f();
			break;
		  case 'u':
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			turn_right();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'U':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  case 'D':
			back();
			follow_line_f();
			break;
		  case 'R':
			back();
			turn_right();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'd':
	    switch(previous){
		  case 'l':
			turn_left();
			follow_line_f();
			break;
		  case 'u':
			turn_left();
			turn_left();
			follow_line_f();
			break;
		  case 'd':
			follow_line_f();
			break;
		  case 'r':
			turn_right();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'U':
			back();
			follow_line_f();
			break;
		  case 'D':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  case 'R':
			back();
			turn_left();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'r':
		switch(previous){
		  case 'l':
			turn_right();
			turn_right();
			follow_line_f();
			break;
		  case 'u':
			turn_right();
			follow_line_f();
			break;
		  case 'd':
			turn_left();
			follow_line_f();
			break;
		  case 'r':
			follow_line_f();
			break;
		  case 'L':
			back();
			follow_line_f();
			break;
		  case 'U':
			back();
			turn_left();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_right();
			follow_line_f();
			break;
		  case 'R':
			TextOut(40,24,  "ERROR");
			running = false;
			break;
		  default:
			break;
		}
		break;
	  case 'L':
		switch(previous){
		  case 'l':
		    follow_line_f();
		    follow_line_f();
			break;
		  case 'u':
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'L':
			follow_line_f();
			break;
		  case 'U':
			back();
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'R':
			back();
			follow_line_f();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'U':
		switch(previous){
		  case 'l':
            turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'u':
			follow_line_f();
			follow_line_f();
			break;
		  case 'd':
			turn_right();
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'r':
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'U':
			follow_line_f();
			break;
		  case 'D':
			back();
			follow_line_f();
			follow_line_f();
			break;
		  case 'R':
			back();
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'D':
		switch(previous){
		  case 'l':
            turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'u':
			turn_right();
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'd':
			follow_line_f();
			follow_line_f();
			break;
		  case 'r':
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'L':
			back();
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'U':
			back();
			follow_line_f();
			follow_line_f();
			break;
		  case 'D':
			follow_line_f();
			break;
		  case 'R':
			back();
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  case 'R':
		switch(previous){
		  case 'l':
            turn_right();
            turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'u':
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'd':
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'r':
			follow_line_f();
			follow_line_f();
			break;
		  case 'L':
			back();
			follow_line_f();
			follow_line_f();
			break;
		  case 'U':
			back();
			turn_left();
			follow_line_f();
			follow_line_f();
			break;
		  case 'D':
			back();
			turn_right();
			follow_line_f();
			follow_line_f();
			break;
		  case 'R':
			follow_line_f();
			break;
		  default:
			break;
		}
		break;
	  default:
		TextOut(40,24,  "FINISH");
		running = false;
		break;
	}
  
    index++;
	previous = current;
// 	current = moves[index];
	current = path[index];
	
  }
  
  
}

void follow_line_f(char basespeed = 90){
  const char EXPECTED_SENSOR_ERROR = 1; //mismatch i lys fra rummet.
  char left_error;
  char left_speed;
  char right_speed;
  char left_previous_error = 0;
  float P, I = 0;
  int   D;
  float kP = 1.7;
  float kI = 0;
  float kD = 0;
  if(basespeed < 0){
	kP = 1.4;
	kI = 0;
	kD = 0.01;
  }
  OnFwd(MOT_L, basespeed);
  OnFwd(MOT_R, basespeed);
  Wait(200);
  int correction = 0;
  bool line_has_ended = false;
  
  while(!line_has_ended){
	TextOut(1,8,  "left");
	TextOut(75,8,  "right");
	TextOut(1,1,  NumToStr(Sensor(LEFT)));
	TextOut(85,1, NumToStr(Sensor(RIGHT)));
	TextOut(40,24,NumToStr(Sensor(CENTER)));

	
// 	if( (Sensor(LEFT)  < THRESHOLD) &&
// 	  (Sensor(RIGHT) < THRESHOLD)
// 	){
	if(Sensor(CENTER) < THRESHOLD_CENTER){
	  Off(MOTOR);
// 	  TextOut(40,24,  "KRYDS");
	  line_has_ended = true;
// 	  PlayTone(1000,200);
	} else {
	  TextOut(40,24,  "     ");
	  TextOut(1,16, NumToStr(left_speed));
	  TextOut(80,16, NumToStr(right_speed));
	  left_error = Sensor(LEFT) - Sensor(RIGHT);
	  TextOut(30,1,"        ");
	  TextOut(40,24,NumToStr(Sensor(CENTER)));
	  // lighting mismatch correction
	  if(left_error > EXPECTED_SENSOR_ERROR){
		left_error -= EXPECTED_SENSOR_ERROR;
	  } else if(left_error < -EXPECTED_SENSOR_ERROR){
		left_error += EXPECTED_SENSOR_ERROR;
	  } else {
		left_error = 0;
	  }
	  P = left_error;
	  I = I + left_error;
	  D = left_error - left_previous_error;
	  left_previous_error = left_error;
	  correction = P * kP + I * kI + D * kD;
	  //roundoff to avoid mayhem
	  if(correction > 20 ){
		correction = 20;
	  } else if(correction < -20){
		correction = -20;
	  }
	  left_speed =  basespeed + correction;
	  right_speed = basespeed - correction;
	  
	  OnFwd(MOT_L, left_speed);
	  OnFwd(MOT_R, right_speed);
	}
	Wait(10); // Generate 100 hz controller
  }
}

void back(){
  //   OnFwd(MOT_L, -60);
  //   OnFwd(MOT_R, -60);
  
  RotateMotorEx(OUT_AB,-60,135,0,true,false);
  turn_left(false);
  follow_line_f(60);
}

void turn_left(bool forward = true){
  if(forward){
	OnFwd(MOT_L, 80);
	OnFwd(MOT_R, 80);
	Wait(300);
  }
  OnFwd(MOT_L, -80);
  OnFwd(MOT_R, 80);
  Wait(400);
  bool turn_completed = false;
  while(!turn_completed){
// 	if(Sensor(CENTER) < 65)
	if(Sensor(LEFT) < 65)
	  turn_completed = true;
  }
  OnFwd(MOT_L, -70);
  OnFwd(MOT_R, 70);
  
  while(Sensor(RIGHT) - Sensor(LEFT) > 3);
//   Wait(80);
//   Off(MOTOR);
} 

void turn_right(bool forward = true){
  if(forward){
	OnFwd(MOT_L, 80);
	OnFwd(MOT_R, 80);
	Wait(300);
  }
  OnFwd(MOT_L, 80);
  OnFwd(MOT_R, -80);
  Wait(400);
  bool turn_completed = false;
  while(!turn_completed){
// 	if(Sensor(CENTER) < 65)
	if(Sensor(RIGHT) < 65)
	  turn_completed = true;
  }
   OnFwd(MOT_L, 40);
  OnFwd(MOT_R, -40);
  
  while(Sensor(LEFT)-Sensor(RIGHT) > 4);
 
  Off(MOTOR);
}
